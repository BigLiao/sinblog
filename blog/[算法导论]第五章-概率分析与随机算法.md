# [算法导论]第五章-概率分析与随机算法

> 上帝从不掷骰子

## 雇用问题

#### 问题描述

把《算法导论》里的问题简化描述一下是这样的：

> 你准备雇用一个助理，原则是只用最好的，所以每面试到一个比当前助理更好的候选人，你就会用他替换，而且你打算一直面试下去。每次面试都要花费少额费用，而每次雇用要花费较大额的费用（遣散费和雇用费）。问题是计算总花费。

用数学的方式描述是，假设一共面试 $n$ 次，发生了 $m$ 次雇用，面试一次费用为 $C_t$，雇用一次的费用为 $C_h$ ，那么总费用为：
$$
S = C_t n + C_h m
$$
其中 $C_h$ 是远大于 $C_t$的。这里需要确定的就是雇用次数 $m$ 。

#### 最好情况

最好的情况就是第一次面试就找到了最好的候选人，也就是 $m=1$，则总花费为：
$$
S = C_t n + C_h
$$

#### 最坏情况

运气不好，每次面试的候选人都比前一个强，那么每次面试后都要雇用一次，即 $m=n$，那么总花费为：
$$
S = (C_t + C_h)n
$$

#### 平均情况

平均情况就是假设候选人能力的分布是均匀的，也就是他们出现的顺序是完全随机的。根据*大数定理*，只要问题的规模足够大，那么他们的一定是按概率分布的。

假设候选人的按能力大小排名为 $Rank<1,2,3,...,n>$，那么出现的顺序 $Seq<1,2,3,...,n>$ 就是 $Rank$ 的一个排列。一共有 $n!$ 种排列，每个排列出现的概率就是 $1/n!$ 。

《导论》里用导论*指示随机变量* 来描述这个概率问题，这里不搞这么复杂，用易懂的方式来分析一下。

分析第 $i$ 次面试的情况，面试顺序为 $Seq<1,2,3,...,i>$，因为顺序是完全随机的，所以每个候选人能力是最强的概率为 $1/i$，所以 $i$ 号候选人会被雇用的概率 $P_i = 1/i$。总的雇用次数可以用数学期望来描述：
$$
E_s = \sum_{i=1}^{n} E_i = \\
\sum_{i=1}^{n} {1\times P_i + 0 \times (1 - P_i)} = 1 +  \frac{1}{n} \\
= 1 + O(1)
$$

$$
S = (C_t + C_h)n
$$
后面这个式子是一个*调和级数*，结果可以用 $f(x)=1/x$ 的定积分来分析，这里不赘述。总之雇用次数是对数级别的，总花费可估计为：
$$
S = C_t n + C_h \lg n + \O(1)
$$

## 随机化算法

前面计算的平均情况是假设候选人分布是均匀的，或者说这是一个**统计意义**上的情况。对于真实情况来讲，总花费是依赖于输入顺序，而输入顺序往往不是那么均匀。为了避免出现最坏情况，使结果达到平均情况，就可以使用随机化算法。

随机化算法就是先将输入的顺序打乱，使之变成均匀随机分布的，这样算法就不依赖于输入的顺序，从而达到期望的情况。也就是我们去掉了假设，制作了随机。下面介绍两种随机化算法：**优先级数组**和**洗牌算法**。

### 优先级数组

对数组中的每个元素 $A[i]$  生成一个随机的优先级 $P[i]$，在排序算法中比较 $P[i]$ 的大小而不是 $A[i]$ ，这样产生的序列就跟 $A[i]$ 的大小无关，而且是完全随机的。

问题的关键在于随机生成优先级 $P[i]$，我们要比较大小，就不能出现相同的优先级，这个时候 $P[i]$ 的随机数范围就要足够大才不会碰撞。而范围越大，生成随机数的时间复杂度也越高。

通常对于 $n$ 个元素的数组，选定的随机范围是 $1 \sim n^3$ ，这个时候所有元素都唯一的概率是 $1 - 1/n$（记住结论吧，证明我也不会）。

构造一个与原数组等长的优先级数组 `p[]`，然后用排序算法排序，按优先级数组大小排序的同时将原数组也排序。

```c++
// 优先级数组随机化算法
#include <iostream>
#include <ctime>
#include <cstdlib>

using namespace std;

void quick_sort(int *al, int *ar, int *pl, int *pr);

void permute_by_sort(int list[], int len) {
    int p[len];
    for (int i = 0; i < len; i++) {
        p[i] = rand() % (len*len*len) + 1;
    }
    quick_sort(list, list + len, p, p + len);
}

// [al, ar)
void quick_sort(int *al, int *ar, int *pl, int *pr) {
    int len = ar -al;
    if (len <= 1) {
        return;
    } else {
        int pt = *pl, at = *al;
        int *aleft = al, *aright = ar - 1, *pleft = pl, *pright = pr - 1;
        while(pleft < pright) {
            while(pleft < pright && *pright >= pt) {
                pright = pright - 1;
                aright = aright - 1;
            }
            if (pleft < pright) {
                *pleft = *(pright);
                *aleft = *(aright);
                pleft = pleft + 1;
                aleft = aleft + 1;
            }
            while(pleft < pright && *pleft <= pt) {
                pleft = pleft + 1;
                aleft = aleft + 1;
            }
            if (pleft < pright) {
                *(pright) = *pleft;
                *(aright) = *aleft;
                pright = pright - 1;
                aright = aright - 1;
            }
        }
        *pleft = pt;
        *aleft = at;
        quick_sort(al, aleft-1, pl, pleft-1);
        quick_sort(aleft+1, ar, pleft+1, pr);
    }
}

int main() {
    srand(time(NULL));
    int list[] = {4, 1, 3, 5, 6, 7, 2, 9};
    permute_by_sort(list, 8);
    for (int i = 0; i < 8; i++) {
        cout << list[i] << ", ";
    }
    return 0;
}
```

这里使用了快速排序，跟一般快速排序的不同之处在于要同时排两个数组。优先级数组变成有序，而原数组就变成了无序。

对这个算法的复杂度进行分析，可以看到这里耗时的地方在于排序，快速排序的时间复杂度为 $\Theta(n\lg n)$，所以总的时间复杂度也是 $\Theta(n\lg n)$ 。空间复杂度为 $\Theta(n)$，因为需要额外长度为 $n$ 的优先级数组。

### 洗牌算法

洗牌算法可以让时间复杂度达到 $\Theta(n)$，而且不需要额外的空间，在原数组上即可完成，关键是算法还非常简单，可以说是必须掌握了！

遍历数组，让第 $i$ 个元素与 $i \sim n$ 随机一个元素交换位置，交换后 $i$ 号元素的位置不再改变。

```c++
void wash_card(int list[], int len) {
    for (int i = 0; i < len; i++) {
        int j = std::rand() % (len - i) + i;
        std::swap(list[i], list[j]);
    }
}
```

这个算法可以说是简单又好用，它可以产生一个*均匀随机排列*，证明部分可以看《导论》。

## 概率分析

### 生日悖论

生日问题： $k$ 个人中至少有两个人生日相同的概率是多少？

这个**生日悖论**就是：至少要多少个人，才能使其中两人生日相同的概率达到 $50\%$ ？

#### 概率论求解

这其实是一个简单的概率论问题。一年有 365 天，设样本空间 $n = 365$，要求 $k$ 个人中至少两个人生日相同的概率 $P_k$。对于这种“至少两个”的概率问题，我们一般从反面求解，也就是求所有人生日都不相同的概率 $\bar{P_k}$。

一个极端的情况，当 $k=366$ 时，显然 $\bar{P_k}=0$，肯定有相同生日的两个人。相反当 $k=1$ 时，$\bar{P_k}=1$。

如果前 $i$ 个人的生日都不相同，那么第 $i+1$ 个人的生日有 $n-i$ 种选择，根据乘法原理一共可能有 $n(n-1)(n-2)...(n-k+1)$ 中情况。而所有可能的生日组合有 $n^k$ 种。所以
$$
\bar{P_k}= \frac{A_n^k}{n^k} = \frac{\frac{n!}{(n-k)!}}{n^k} \\
= \frac{n(n-1)(n-2)...(n-k+1)}{n^k} \\
= 1\cdot(\frac{n-1}{n})(\frac{n-2}{n})...(\frac{n-k+1}{n}) \\
= 1\cdot(1-\frac{1}{n})(1-\frac{2}{n})...(1-\frac{k-1}{n}) \\
\le e^{-\sum_{i=1}^{k-1}i/n} = e^{-k(k-1)/2n}
$$
最后这个不等式是根据*伯努利不等式* $1+x\le e^x$ 得出的，这里不给证明。

要求**生日悖论**的 $P_k \ge 1/2$，即 $\bar{P_k} \lt 1/2$，把 $n = 365$ 代入可得：
$$
\bar{P_k} \le e^{-k(k-1)/2n} = 1/2 \\
\Rightarrow k \ge 23
$$
也就是说，如果 23 个人在一间屋子里，那么至少两个人同一天生日的概率超过 $1/2$ 。我们把它叫生日悖论，是因为这个数字远比我们想象的小。

如果让 $P_k \ge 99\%$，则可以解得 $k \ge 59$。也就是说，59 个人里出现相同生日的概率超过 $99\%$。